 """
    en premier le mots de passe doit etre hasher en md5
    ensuite s'authentifier 

    """

    BASE_URL = "https://mdm.medulla-tech.io/rest"
    login = "admin"
    password = "MeduHmdm@12"

    def hash_password(password: str) ->str:
        hashed_pwd = hashlib.md5(password.encode()).hexdigest().upper()
        return hashed_pwd

    # Authentification 

    def authenticate(login: str, hashed_pwd: str) -> str:
        url = f"{BASE_URL}/public/jwt/login"
        headers = {"Content-Type": "application/json"}
        data = {
            "login": login,
            "password": hashed_pwd
        }

        try:
            resp = requests.post(url, json=data, headers=headers)
            resp.raise_for_status()
            token = resp.json().get("id_token")

            if not token:
                raise Exception("Le token JWT est manquant dans la réponse.")

            logging.getLogger().info(f"Authentification réussie : {token}")
            return token

        except Exception as e:
            logging.getLogger().error(f"Erreur lors de l'authentification : {e}")
            return None



def devicelist(self, hmdmtoken: str):
    url = f"{self.BASE_URL}/private/devices/search"  
    hmdmsearch = {}

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {hmdmtoken}"
    }

    try:
        resp = requests.post(url, json=hmdmsearch, headers=headers)
        resp.raise_for_status()

        hmdmlist = resp.json()

        if not hmdmlist:
            raise Exception("La liste des devices n'a pas été récupérée")

        logging.getLogger().info("La liste a bien été récupérée.")
        return hmdmlist

    except Exception as e:
        logging.getLogger().error(f"La liste n'a pas été récupérée : {e}")
        return None

#### ce fichier est de test inutile 

les fichier web 
/usr/share/mmc/modules/mobile/mobile -> /root/GIT/medulla/web/modules/mobile










git sync :
import shutil
import subprocess
import os
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

# Dictionnaire des répertoires source et destination
paths = {
    "/usr/share/mmc/modules/mobile": "/root/GIT/medulla/web/modules/mobile",
    "/usr/lib/python3/dist-packages/mmc/plugins/mobile": "/root/GIT/medulla/services/mmc/plugins/mobile",
    "/usr/lib/python3/dist-packages/pulse2/database/mobile": "/root/GIT/medulla/services/pulse2/database/mobile",
    "/usr/share/doc/pulse2/contrib/mobile/sql": "/root/GIT/medulla/services/contrib/mobile/sql"
}

# Fonction pour copier les fichiers
def copy_files(src, dest):
    if os.path.exists(src):
        if os.path.isdir(src):
            shutil.copytree(src, dest, dirs_exist_ok=True)
        else:
            shutil.copy(src, dest)
        print(f"Fichiers copiés de {src} vers {dest}")
    else:
        print(f"{src} n'existe pas.")

# Fonction pour exécuter des commandes Git
def run_git_command(command):
    try:
        subprocess.run(command, check=True, text=True, capture_output=True)
        print(f"Commande exécutée : {' '.join(command)}")
    except subprocess.CalledProcessError as e:
        print(f"Erreur lors de l'exécution de la commande : {e}")

# Classe de gestion des événements pour surveiller les fichiers
class ChangeHandler(FileSystemEventHandler):
    def on_modified(self, event):
        if event.src_path in paths:
            print(f"Modification détectée dans {event.src_path}")
            copy_files(event.src_path, paths[event.src_path])
            run_git_command(["git", "add", "."])
            run_git_command(["git", "commit", "-m", "Mise à jour des fichiers mobiles"])
            run_git_command(["git", "push", "origin", "main"])

# Surveiller les répertoires
def start_watcher():
    event_handler = ChangeHandler()
    observer = Observer()

    for src in paths.keys():
        observer.schedule(event_handler, src, recursive=True)

    observer.start()
    print("Surveillance des changements en cours...")

    try:
        while True:
            pass  # Garder le script actif
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

# Lancer la surveillance
start_watcher()

